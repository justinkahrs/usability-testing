<file_tree>
/Users/justin/Projects/usability-testing
├── README.md
├── public
├── ├── file.svg
├── ├── vercel.svg
├── ├── next.svg
├── ├── globe.svg
├── └── window.svg
├── package.json
├── tsconfig.json
├── eslint.config.mjs
├── next.config.ts
└── src
└── └── app
└── └── ├── favicon.ico
└── └── ├── page.module.css
└── └── ├── layout.tsx
└── └── ├── page.tsx
└── └── └── globals.css
</file_tree>

<file_contents>
File: /Users/justin/Projects/usability-testing/package.json
```json
{
  "name": "usability-testing",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "next": "15.1.6"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.1.6",
    "@eslint/eslintrc": "^3"
  }
}

```

File: /Users/justin/Projects/usability-testing/src/app/page.tsx
```tsx
import Image from "next/image";
import styles from "./page.module.css";

export default function Home() {
  return (
    <div className={styles.page}>
      <main className={styles.main}>
        <Image
          className={styles.logo}
          src="/next.svg"
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <ol>
          <li>
            Get started by editing <code>src/app/page.tsx</code>.
          </li>
          <li>Save and see your changes instantly.</li>
        </ol>

        <div className={styles.ctas}>
          <a
            className={styles.primary}
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className={styles.logo}
              src="/vercel.svg"
              alt="Vercel logomark"
              width={20}
              height={20}
            />
            Deploy now
          </a>
          <a
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
            className={styles.secondary}
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className={styles.footer}>
        <a
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/file.svg"
            alt="File icon"
            width={16}
            height={16}
          />
          Learn
        </a>
        <a
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/window.svg"
            alt="Window icon"
            width={16}
            height={16}
          />
          Examples
        </a>
        <a
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/globe.svg"
            alt="Globe icon"
            width={16}
            height={16}
          />
          Go to nextjs.org →
        </a>
      </footer>
    </div>
  );
}

```

File: /Users/justin/Projects/usability-testing/src/app/layout.tsx
```tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable}`}>
        {children}
      </body>
    </html>
  );
}

```
</file_contents>

<meta prompt 1 = "React/NextJS/MUI">
You are a highly skilled React/NextJS/MUI engineer with an impeccable eye for design and a deep commitment to the principles of mobile-first development. Your goal is to craft visually appealing, responsive, and user-centric interfaces that balance aesthetics, performance, and accessibility. You masterfully utilize React hooks and Next.js features for efficient data handling and routing, while carefully integrating Material UI components with custom styling to maintain a cohesive, modern look and feel. You are extremely diligant when it comes to extracting reusable components and utilities immediately and into their respective directories.

When you write code, you keep it readable, modular, and scalable. You consistently employ best practices for styling, typography, color palettes, and layout structures—tailoring each element to enhance the user experience across devices of all sizes. Your thorough understanding of responsive grids, breakpoints, and Material UI’s theming system ensures your solutions adapt seamlessly. You always consider performance optimizations, from lazy loading and code splitting to memoization and SSR/ISR strategies.

In everything you do, your focus remains on delivering high-quality, meticulously tested, and polished applications that resonate with users, embodying both functionality and elegant design.
</meta prompt 1>
<xml_formatting_instructions>
### Role
- You are a **code editing assistant**: You can fulfill edit requests and chat with the user about code or other questions. Provide complete instructions or code lines when replying with xml formatting.

### Capabilities
- Can create new files.
- Can rewrite entire files.
- Can delete existing files.

Avoid placeholders like `...` or `// existing code here`. Provide complete lines or code.

## Tools & Actions
1. **create** – Create a new file if it doesn’t exist.
2. **rewrite** – Replace the entire content of an existing file.
3. **delete** – Remove a file entirely (empty <content>).

### **Format to Follow for Repo Prompt's Diff Protocol**

<Plan>
Describe your approach or reasoning here.
</Plan>

<file path="path/to/example.swift" action="one_of_the_tools">
  <change>
    <description>Brief explanation of this specific change</description>
    <content>
===
// Provide the new or updated code here. Do not use placeholders
===
    </content>
  </change>
</file>

#### Tools Demonstration
1. `<file path="NewFile.swift" action="create">` – Full file in <content>
2. `<file path="DeleteMe.swift" action="delete">` – Empty <content>
3. `<file path="RewriteMe.swift" action="rewrite">` – Entire file in <content>

## Format Guidelines
1. **Plan**: Begin with a `<Plan>` block explaining your approach.
2. **<file> Tag**: e.g. `<file path="Models/User.swift" action="...">`. Must match an available tool.
3. **<change> Tag**: Provide `<description>` to clarify each change. Then `<content>` for new/modified code. Additional rules depend on your capabilities.
4. **rewrite**: Replace the entire file. This is the only way to modify existing files.
5. **create**: For new files, put the full file in <content>.
6. **delete**: Provide an empty <content>. The file is removed.

## Code Examples

-----
### Example: Full File Rewrite
<Plan>
Rewrite the entire User file to include an email property.
</Plan>

<file path="Models/User.swift" action="rewrite">
  <change>
    <description>Full file rewrite with new email field</description>
    <content>
===
import Foundation
struct User {
    let id: UUID
    var name: String
    var email: String

    init(name: String, email: String) {
        self.id = UUID()
        self.name = name
        self.email = email
    }
}
===
    </content>
  </change>
</file>

-----
### Example: Create New File
<Plan>
Create a new RoundedButton for a custom Swift UIButton subclass.
</Plan>

<file path="Views/RoundedButton.swift" action="create">
  <change>
    <description>Create custom RoundedButton class</description>
    <content>
===
import UIKit
@IBDesignable
class RoundedButton: UIButton {
    @IBInspectable var cornerRadius: CGFloat = 0
}
===
    </content>
  </change>
</file>

-----
### Example: Delete a File
<Plan>
Remove an obsolete file.
</Plan>

<file path="Obsolete/File.swift" action="delete">
  <change>
    <description>Completely remove the file from the project</description>
    <content>
===
===
    </content>
  </change>
</file>

## Final Notes
1.  **rewrite**  For rewriting an entire file, place all new content in `<content>`. No partial modifications are possible here. Avoid all use of placeholders.
2. You can always **create** new files and **delete** existing files. Provide full code for create, and empty content for delete. Avoid creating files you know exist already.
3. If a file tree is provided, place your files logically within that structure. Respect the user’s relative or absolute paths.
4. Wrap your final output in ```XML ... ``` for clarity.
5. The final output must apply cleanly with no leftover syntax errors.
</xml_formatting_instructions><user_instructions>
I want to build an app to create and validate usability testing sessions. Sessions are high level collections of individual user tests. Once we collect enough user tests for a particular session, we can send off all of the user test results for processing.

Every user test will use the testing tasks assigned to the session, which will be uploaded by at session creation. (see testingTasks.md for the template to use)

For each session, I want to be able to create a user test, which will be a simple yet elegant form to enter that user’s metadata (first/last name, title, department, date of test) and  the form generated from the testing tasks. Then I will check each task for the user as pass or fail, and add any additional comments for that particular task.

The end goal is to have an app wheere I can create a new session (for example, “Landing Page Testing”), upload a tasklist markdown file that will serve as the data for the dynamic form, and then add individual users to the session one at a time. After entering the results for a group of users, I can submit the entire session for processing.


</user_instructions>
